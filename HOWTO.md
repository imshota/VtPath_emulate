# 実装方法 Pre
 ## Tritonで他の仮想パスを探索する入力を見つけ、VP集合を作る。
 - アルゴリズム
   - エミュレートで最初の仮想パスを入手。
   - ターゲット分岐アドレスにおいて、Tritonでもう一方の分岐にいく入力を見つける。
   - その入力をTritonのエミュレートで使い、もう一方の仮想パスを入手
 - 出来上がった仮想パスは、ファイルに出力する予定。
 - 今回は一つの分岐を探索する。
   - attacktest.cpp 28行目 if( mode == 0 )
   - エントリアドレスは 4008b6 ターゲットアドレスは 400938
   - シンボリック設定ファイルは [ここ](https://github.com/imshota/VtPath_emulate/blob/master/attack.map)
 
 ## Pinで実際に実行するファイルを検査し、仮想パスがあっているか判定する。
 - アルゴリズム
   - 関数ごとに計装 (91行目)
     - 関数のリターンアドレスをVStackにpush。
     - 関数内の命令を順に見ていき、syscall命令なら、
       - syscall命令のアドレスをVStackにpush。
       - preVStackとVStackを比較して、VtPathを作り、保存。
       - VStackをpreVStackにコピーし、popする。
     - 関数の最後まできたら、popする。
   - 保存してきたVtPathをVP集合に属しているか判定
     - 入っている　→　異常なし
     - 入っていない　→　異常(パス異常)
 - VStack, preStackはstack型で保存
 - VtPathの作り方はまだできていない。(型はvector型にしようと）
 
 ## 問題
 - Tritonでターゲットアドレスについて、コードカバレッジ向上ツール(PBA13.4参照)が使えない。
   - 使えたが、また新しい問題
   - エントリポイントを変えなければいけない可能性がある。
 - Pinで検査する時、scanfの文字が入力済みである実行コードをどのように作ればいいのか。
 - MyPinToolは関数ごとに計装しているので、関数外のシステムコールを計装できていない。
 - VtPathを作る際、任意の関数のエントリポイントとエンドポイントのアドレスが欲しい。
 
